from django.db import models
from django.utils import timezone


class Store(models.Model):
    name = models.CharField(max_length=100)
    address = models.TextField()
    phone = models.CharField(max_length=15)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.name


class User(models.Model):

    # info
    username = models.CharField(max_length=32, unique=True)
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=15, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    # roles
    is_driver = models.BooleanField(default=False)
    is_customer_service = models.BooleanField(default=False)
    is_manager = models.BooleanField(default=False)

    # stores
    stores = models.ManyToManyField(Store, related_name='users')

    def __str__(self):
        return self.username

"""

class DeliveryStatus:
    ORDER_PLACED = 'ORDER_PLACED'
    COMPLETE = 'complete'
    ACCEPTED = 'accepted'
    IN_PROGRESS = 'in-progress'
    MISDELIVERY = 'misdelivery'
    REDELIVERY_ASSIGNED = 'redelivery_assigned'
    REDELIVERY_IN_PROGRESS = 'redelivery_in_progress'
    REDELIVERY_COMPLETE = 'redelivery_complete'
    CANCELED = 'canceled'

    CHOICES = [
        (ORDER_PLACED, 'Order Placed'),
        (COMPLETE, 'complete'),
        (ACCEPTED, 'accepted'),
        (IN_PROGRESS, 'in-progress'),
        (MISDELIVERY, 'misdelivery'),
        (REDELIVERY_ASSIGNED, 'redelivery_assigned'),
        (REDELIVERY_IN_PROGRESS, 'redelivery_in_progress'),
        (REDELIVERY_COMPLETE, 'redelivery_complete'),
        (CANCELED, 'canceled')
    ]

class Store(models.Model):
    name = models.CharField(max_length=100)
    address = models.TextField()
    phone = models.CharField(max_length=15)

    def __str__(self):
        return self.name

class OrderAssignment(models.Model):
    class Assignment_Type(models.TextChoices):
        DELIVERY = 'delivery'
        REDELIVERY = 'redelivery'
        FOLLOW_UP = 'follow_up'


    order = models.ForeignKey(Order, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    assigned_at = models.DateTimeField(auto_now_add=True)
    role_at_time_of_assignment

class Order(models.Model):
    # Foreign key to Store - allows one store per order
    store = models.ForeignKey(
        Store,
        on_delete=models.CASCADE,
        related_name='orders'
    )
    
    # Order fields
    order_number = models.CharField(max_length=100, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # info
    creation_date = models.DateTimeField(default=timezone.now)
    delivery_date = models.DateTimeField()
    preferred_delivery_time = models.TimeField(blank=True, null=True)
    address = models.CharField(max_length=150)
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    phone_num = models.CharField(max_length=20)
    invoice_num = models.CharField(max_length=30)
    notes = models.TextField(blank=True, null=True)
    delivery_instructions = models.TextField(blank=True, null=True)
    customer_email = models.EmailField(max_length=150)
    customer_num = models.CharField(max_length=20)

    # stasus
    delivery_status = models.CharField(max_length=80, choices=DeliveryStatus.CHOICES, default=DeliveryStatus.ORDER_PLACED)

    # assigned users
    assigned_users = models.ManyToManyField(
        'User',
        through='OrderAssignment',
        related_name='assigned_orders'
    )

class User(models.Model):

    # info
    username = models.CharField(max_length=32, unique=True)
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=15, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    # roles
    is_driver = models.BooleanField(default=False)
    is_customer_service = models.BooleanField(default=False)
    is_manager = models.BooleanField(default=False)

    # stores
    stores = models.ManyToManyField(Store, related_name='users')

    def __str__(self):
        return self.username



# In your view or wherever you're changing the order status
# order._change_user = request.user  # Set the user before saving
@receiver(pre_save, sender=Order)
def track_status_change(sender, instance, **kwargs):
    try:
        if instance.pk:
            previous = Order.objects.get(pk=instance.pk)
            if previous.delivery_status != instance.delivery_status:
                user = getattr(instance, '_change_user', None)
                
                notes = None
                if instance.delivery_status == DeliveryStatus.MISDELIVERY:
                    notes = "Order marked as misdelivery"
                elif instance.delivery_status == DeliveryStatus.COMPLETE:
                    notes = "Delivery completed"
                elif instance.delivery_status == DeliveryStatus.REDELIVERY_ASSIGNED:
                    notes = "Redelivery has been assigned"
                
                # Create status history and get currently assigned users
                history = StatusHistory.objects.create(
                    order=instance,
                    old_status=previous.delivery_status,
                    new_status=instance.delivery_status,
                    changed_by=user,
                    notes=notes
                )
                
                # Add currently assigned users to the history
                currently_assigned = instance.assigned_users.all()
                if currently_assigned.exists():
                    history.assigned_users.add(*currently_assigned)
                    user_names = ", ".join([user.get_full_name() or user.username for user in currently_assigned])
                    history.notes = f"{notes or ''}\nAssigned users: {user_names}".strip()
                    history.save()

    except Order.DoesNotExist:
        pass

class StatusHistory(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='status_history')
    old_status = models.CharField(max_length=80, choices=DeliveryStatus.CHOICES)
    new_status = models.CharField(max_length=80, choices=DeliveryStatus.CHOICES)
    timestamp = models.DateTimeField(default=timezone.now)
    changed_by = models.ForeignKey(
        User, 
        on_delete=models.SET_NULL, 
        null=True,
        related_name='status_changes'
    )
    assigned_users = models.ManyToManyField(
        User,
        related_name='status_history_assignments',
        blank=True
    )
    notes = models.TextField(blank=True, null=True)

    class Meta:
        ordering = ['-timestamp']
        verbose_name_plural = 'Status histories'

    def __str__(self):
        return f"Order {self.order.order_number} changed from {self.old_status} to {self.new_status} at {self.timestamp}"
"""